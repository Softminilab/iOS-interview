# iOS设计模式分类

## 1. 创建型模式

创建型模式关注对象的创建过程，帮助创建对象的同时隐藏创建逻辑。

- **单例模式 (Singleton)**：确保类只有一个实例，并提供全局访问点
  - 例如：`UserDefaults.standard`, `URLSession.shared`
- **工厂方法模式 (Factory Method)**：定义创建对象的接口，让子类决定实例化哪个类
  - 例如：创建不同类型的视图控制器
- **抽象工厂模式 (Abstract Factory)**：创建一系列相关或相互依赖的对象
  - 例如：为不同主题创建UI组件族
- **建造者模式 (Builder)**：分步骤构建复杂对象，同样的构建过程可以创建不同表示
  - 例如：复杂表单或设置界面构建
- **原型模式 (Prototype)**：通过复制现有实例来创建新实例
  - 例如：深拷贝复杂对象结构

## 2. 结构型模式

结构型模式关注类和对象的组合，形成更大的结构。

- **适配器模式 (Adapter)**：将一个类的接口转换成客户期望的另一个接口
  - 例如：兼容旧API与新API
- **桥接模式 (Bridge)**：将抽象部分与实现部分分离，使它们可以独立变化
  - 例如：主题引擎与UI组件分离
- **组合模式 (Composite)**：将对象组合成树形结构表示"部分-整体"层次
  - 例如：视图层次结构
- **装饰器模式 (Decorator)**：动态地给对象添加额外的职责
  - 例如：为UIView添加圆角、阴影等效果
- **外观模式 (Facade)**：为子系统提供一个统一的接口
  - 例如：API客户端封装多个网络请求
- **享元模式 (Flyweight)**：通过共享技术有效支持大量细粒度对象
  - 例如：表格/列表中的复用单元格
- **代理模式 (Proxy)**：为其他对象提供一个替代或占位符以控制对这个对象的访问
  - 例如：懒加载图片，远程服务代理

## 3. 行为型模式

行为型模式关注对象之间的通信和责任分配。

- **责任链模式 (Chain of Responsibility)**：让多个对象都有机会处理请求
  - 例如：事件响应链，异常处理
- **命令模式 (Command)**：将请求封装成对象
  - 例如：动作操作，撤销/重做功能
- **解释器模式 (Interpreter)**：为语言定义文法表示并解释
  - 例如：正则表达式解析，DSL解释器
- **迭代器模式 (Iterator)**：提供顺序访问集合元素的方法
  - 例如：自定义集合遍历
- **中介者模式 (Mediator)**：定义对象间通信的中介对象
  - 例如：协调多个视图控制器
- **备忘录模式 (Memento)**：捕获对象内部状态用于恢复
  - 例如：应用状态保存/恢复
- **观察者模式 (Observer)**：定义对象间一对多的依赖关系
  - 例如：KVO, NotificationCenter, Combine
- **状态模式 (State)**：对象在状态改变时改变行为
  - 例如：视图控制器状态管理
- **策略模式 (Strategy)**：定义算法族并使其可互换
  - 例如：不同的排序/过滤策略
- **模板方法模式 (Template Method)**：定义算法骨架，延迟步骤实现到子类
  - 例如：视图控制器生命周期方法
- **访问者模式 (Visitor)**：表示作用于元素的操作
  - 例如：对复杂数据结构的不同操作

## 4. iOS特有的设计模式

- **代理模式 (Delegation)**：Apple框架中广泛使用
  - 例如：`UITableViewDelegate`, `UITextFieldDelegate`
- **目标-动作模式 (Target-Action)**：用于处理控件事件
  - 例如：按钮点击事件处理
- **MVVM/MVC/MVP/VIPER**：应用架构模式
  - 控制应用的整体结构和数据流
- **协调器模式 (Coordinator)**：处理视图控制器间的导航和流程
  - 分离导航逻辑与UI逻辑
- **服务定位器模式 (Service Locator)**：提供集中式服务访问
  - 例如：依赖注入容器

这些设计模式可以单独使用，也可以组合使用以解决复杂问题。选择合适的设计模式应基于特定的业务需求、代码复杂度和团队熟悉度。